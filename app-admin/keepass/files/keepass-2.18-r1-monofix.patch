diff --git a/KeePass/Forms/PwEntryForm.cs b/KeePass/Forms/PwEntryForm.cs
index 4057d3b..94abc20 100644
--- a/KeePass/Forms/PwEntryForm.cs
+++ b/KeePass/Forms/PwEntryForm.cs
@@ -1609,8 +1609,17 @@ namespace KeePass.Forms
 			return base.ProcessDialogKey(keyData);
 		}
 
+		private bool m_bClosing = false; // Mono bug workaround
 		private void OnFormClosing(object sender, FormClosingEventArgs e)
 		{
+			if(m_bClosing) return;
+			m_bClosing = true;
+			HandleFormClosing(e);
+			m_bClosing = false;
+		}
+
+		private void HandleFormClosing(FormClosingEventArgs e)
+		{
 			bool bCancel = false;
 			if(!m_bForceClosing && (m_pwEditMode != PwEditMode.ViewReadOnlyEntry))
 			{
diff --git a/KeePass/KeePass.csproj b/KeePass/KeePass.csproj
index e1455c6..5092dcc 100644
--- a/KeePass/KeePass.csproj
+++ b/KeePass/KeePass.csproj
@@ -973,6 +973,7 @@
     <Compile Include="Util\IpcBroadcast.Fsw.cs" />
     <Compile Include="Util\IpcUtilEx.cs" />
     <Compile Include="Util\KeyUtil.cs" />
+    <Compile Include="Util\MonoWorkarounds.cs" />
     <Compile Include="Util\NetUtil.cs" />
     <Compile Include="Util\PwGeneratorUtil.cs" />
     <Compile Include="Util\SearchUtil.cs" />
diff --git a/KeePass/UI/GlobalWindowManager.cs b/KeePass/UI/GlobalWindowManager.cs
index 2788156..11871fe 100644
--- a/KeePass/UI/GlobalWindowManager.cs
+++ b/KeePass/UI/GlobalWindowManager.cs
@@ -25,6 +25,7 @@ using System.Windows.Forms;
 using System.Drawing;
 
 using KeePass.App;
+using KeePass.Util;
 
 using KeePassLib.Native;
 using KeePassLib.Utility;
@@ -122,6 +123,8 @@ namespace KeePass.UI
 
 			CustomizeControl(form);
 
+			MonoWorkarounds.ApplyTo(form);
+
 			if(GlobalWindowManager.WindowAdded != null)
 				GlobalWindowManager.WindowAdded(null, new GwmWindowEventArgs(
 					form, wnd));
@@ -148,6 +151,8 @@ namespace KeePass.UI
 						GlobalWindowManager.WindowRemoved(null, new GwmWindowEventArgs(
 							form, m_vWindows[i].Value));
 
+					MonoWorkarounds.Release(form);
+
 					m_vWindows.RemoveAt(i);
 					return;
 				}
diff --git a/KeePass/Util/MonoWorkarounds.cs b/KeePass/Util/MonoWorkarounds.cs
new file mode 100644
index 0000000..7124efe
--- /dev/null
+++ b/KeePass/Util/MonoWorkarounds.cs
@@ -0,0 +1,205 @@
+ï»¿/*
+  KeePass Password Safe - The Open-Source Password Manager
+  Copyright (C) 2003-2012 Dominik Reichl <dominik.reichl@t-online.de>
+
+  This program is free software; you can redistribute it and/or modify
+  it under the terms of the GNU General Public License as published by
+  the Free Software Foundation; either version 2 of the License, or
+  (at your option) any later version.
+
+  This program is distributed in the hope that it will be useful,
+  but WITHOUT ANY WARRANTY; without even the implied warranty of
+  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+  GNU General Public License for more details.
+
+  You should have received a copy of the GNU General Public License
+  along with this program; if not, write to the Free Software
+  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
+*/
+
+using System;
+using System.Collections.Generic;
+using System.Text;
+using System.Windows.Forms;
+using System.ComponentModel;
+using System.Reflection;
+using System.Diagnostics;
+
+using KeePassLib.Native;
+
+namespace KeePass.Util
+{
+	public static class MonoWorkarounds
+	{
+		private static bool? m_bReq = null;
+		public static bool IsRequired
+		{
+			get
+			{
+				if(!m_bReq.HasValue) m_bReq = NativeLib.IsUnix();
+				return m_bReq.Value;
+			}
+		}
+
+		public static void ApplyTo(Form f)
+		{
+			if(!MonoWorkarounds.IsRequired) return;
+			if(f == null) { Debug.Assert(false); return; }
+
+			ApplyToControlsRec(f.Controls, f, MonoWorkarounds.ApplyToControl);
+		}
+
+		public static void Release(Form f)
+		{
+			if(!MonoWorkarounds.IsRequired) return;
+			if(f == null) { Debug.Assert(false); return; }
+
+			ApplyToControlsRec(f.Controls, f, MonoWorkarounds.ReleaseControl);
+		}
+
+		private delegate void MwaControlHandler(Control c, Form fContext);
+
+		private static void ApplyToControlsRec(Control.ControlCollection cc,
+			Form fContext, MwaControlHandler fn)
+		{
+			if(cc == null) { Debug.Assert(false); return; }
+
+			foreach(Control c in cc)
+			{
+				fn(c, fContext);
+				ApplyToControlsRec(c.Controls, fContext, fn);
+			}
+		}
+
+		private sealed class MwaHandlerInfo
+		{
+			private readonly Delegate m_fnOrg; // May be null
+			public Delegate FunctionOriginal
+			{
+				get { return m_fnOrg; }
+			}
+
+			private readonly Delegate m_fnOvr;
+			public Delegate FunctionOverride
+			{
+				get { return m_fnOvr; }
+			}
+
+			private readonly DialogResult m_dr;
+			public DialogResult Result
+			{
+				get { return m_dr; }
+			}
+
+			private readonly Form m_fContext;
+			public Form FormContext
+			{
+				get { return m_fContext; }
+			}
+
+			public MwaHandlerInfo(Delegate fnOrg, Delegate fnOvr, DialogResult dr,
+				Form fContext)
+			{
+				m_fnOrg = fnOrg;
+				m_fnOvr = fnOvr;
+				m_dr = dr;
+				m_fContext = fContext;
+			}
+		}
+
+		private static void ApplyToControl(Control c, Form fContext)
+		{
+			Button btn = (c as Button);
+			if(btn != null) ApplyToButton(btn, fContext);
+		}
+
+		private static EventHandlerList GetEventHandlers(Component c,
+			out object objClickEvent)
+		{
+			FieldInfo fi = typeof(Control).GetField("ClickEvent", // Mono
+				BindingFlags.Static | BindingFlags.NonPublic);
+			if(fi == null)
+				fi = typeof(Control).GetField("EventClick", // .NET
+					BindingFlags.Static | BindingFlags.NonPublic);
+			if(fi == null) { Debug.Assert(false); objClickEvent = null; return null; }
+
+			objClickEvent = fi.GetValue(null);
+			if(objClickEvent == null) { Debug.Assert(false); return null; }
+
+			PropertyInfo pi = typeof(Component).GetProperty("Events",
+				BindingFlags.Instance | BindingFlags.NonPublic);
+			return (pi.GetValue(c, null) as EventHandlerList);
+		}
+
+		private static Dictionary<object, MwaHandlerInfo> m_dictHandlers =
+			new Dictionary<object, MwaHandlerInfo>();
+		private static void ApplyToButton(Button btn, Form fContext)
+		{
+			DialogResult dr = btn.DialogResult;
+			if(dr == DialogResult.None) return; // No workaround required
+
+			object objClickEvent;
+			EventHandlerList ehl = GetEventHandlers(btn, out objClickEvent);
+			if(ehl == null) { Debug.Assert(false); return; }
+			Delegate fnClick = ehl[objClickEvent]; // May be null
+
+			EventHandler fnOvr = new EventHandler(MonoWorkarounds.OnButtonClick);
+			m_dictHandlers[btn] = new MwaHandlerInfo(fnClick, fnOvr, dr, fContext);
+			btn.DialogResult = DialogResult.None;
+			ehl[objClickEvent] = fnOvr;
+		}
+
+		private static void ReleaseControl(Control c, Form fContext)
+		{
+			Button btn = (c as Button);
+			if(btn != null) ReleaseButton(btn, fContext);
+		}
+
+		private static void ReleaseButton(Button btn, Form fContext)
+		{
+			MwaHandlerInfo hi;
+			m_dictHandlers.TryGetValue(btn, out hi);
+			if(hi == null) return;
+
+			object objClickEvent;
+			EventHandlerList ehl = GetEventHandlers(btn, out objClickEvent);
+			if(ehl == null) { Debug.Assert(false); return; }
+
+			if(hi.FunctionOriginal != null)
+				ehl[objClickEvent] = hi.FunctionOriginal;
+			else ehl.RemoveHandler(objClickEvent, hi.FunctionOverride);
+
+			btn.DialogResult = hi.Result;
+			m_dictHandlers.Remove(btn);
+		}
+
+		private static void OnButtonClick(object sender, EventArgs e)
+		{
+			Button btn = (sender as Button);
+			if(btn == null) { Debug.Assert(false); return; }
+
+			MwaHandlerInfo hi;
+			m_dictHandlers.TryGetValue(btn, out hi);
+			if(hi == null) { Debug.Assert(false); return; }
+
+			Form f = hi.FormContext;
+
+			// Set current dialog result by setting the form's private
+			// variable; the DialogResult property can't be used,
+			// because it raises close events
+			FieldInfo fiRes = typeof(Form).GetField("dialog_result",
+				BindingFlags.Instance | BindingFlags.NonPublic);
+			if(fiRes == null) { Debug.Assert(false); return; }
+			if(f != null) fiRes.SetValue(f, hi.Result);
+
+			if(hi.FunctionOriginal != null)
+				hi.FunctionOriginal.Method.Invoke(hi.FunctionOriginal.Target,
+					new object[]{ btn, e });
+
+			// Raise close events, if the click event handler hasn't
+			// reset the dialog result
+			if((f != null) && (f.DialogResult == hi.Result))
+				f.DialogResult = hi.Result; // Raises close events
+		}
+	}
+}
